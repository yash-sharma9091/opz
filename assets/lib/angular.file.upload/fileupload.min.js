angular.module('filevalidate',[]).directive('ngFileupload', ['$parse','$timeout','appServices', function ($parse,$timeout,appServices) {

  return {
    restrict: 'A',
    require: 'ngModel',
    scope:{
      ngFileupload:'=',
      message:'=',
      maxfile:"="

    },

    link: function(scope,ele, attrs,ngModel )
      {
      //  var model=$parse(attrs.ngFileupload);
      //  var modeldata=model.assign;
      //  var error=$parse(attrs.message);
      //  var modelerror=error.assign;
      

      	var filesize=attrs.filesize;
        var max=parseInt(attrs.max);
        filedata=[];
        var imagetype="jpg|jpeg|png|gif|bmb";
        var doctype="jpg|jpeg|png|gif|bmb";
        var message;
        var fileCount=0;
          //on change event
           ele.bind('change', function($event){
           
              var file={};
              angular.forEach(ele[0].files, function(value,index)
                {

                  fileCount++;
                  if(fileCount<=max)
                  if(value.size<filesize)
                  {
                  var filetype=value.name;

                  if(attrs.fileType=="image")
                  {

                        if(filetype.match(/\.(jpg|jpeg|png|gif|bmp)$/))
                        {
                            message="valid";
                            //push file on array
                           file["name"]=value.name;
                           file["value"]=value;
                           filedata.push(file);
           


                        }
                        else
                         {
                            message="invalid";
                        }
                  }
                  if(attrs.fileType=="document")
                  {
                    if(filetype.match(/\.(doc|zip|rar|docx|xls|xlsx|pdf|rtf|txt|odt|ods|ott|fodt|uot|sas)$/))
                    {
                        message="valid";
                        //push file on array
                       file["name"]=value.name;
                       file["value"]=value;
                       filedata.push(file);

                    }
                    else
                     {
                        message="invalid";
                    }
                  }

                    if(attrs.fileType=="all")
                    {
                          //push file on array
                         file["name"]=value.name;
                         file["value"]=value;
                         filedata.push(file);
                         message="valid";
                  }

                file={};
              }
              else
              {
                 message="invalid";
              }

              else {
                  scope.$apply(scope.maxfile,true);
                  $timeout(function()
                  {
                  appServices.alert("Maximum 20 files allowed to upload ",'error-toast');
                  },300)

              }
              });

              if(scope.ngFileupload)
              {
                  angular.forEach(filedata, function(value){
                      scope.ngFileupload.push(value);

                    
                  });

              }
              else {
                scope.ngFileupload=filedata;
              }

              filedata=[];

              scope.message=message;

              scope.$apply(scope.ngFileupload);
              scope.$apply(scope.message);
            // scope.$apply(function(){modeldata(scope, data);});
            // scope.$apply(function(){modelerror(scope, message);});


              $event.target.value="";

           })
    }
  }
}]).directive('imgPreview', ['$parse','$timeout', function ($parse,$timeout) {
      return {
        restrict: 'A',
        scope:{
          file:"=",
          view:"="
        },
        link: function(scope,ele, attrs,ngModel )
        {

        if(angular.equals({},scope.file)==false){


          $timeout(function(){
          var file=scope.file;

          var type=file.name.match(/\.(jpg|jpeg|png|gif)$/);
          if(type)
          {
            scope.view="image";
            scope.$apply(scope.view)
            $timeout(function(){
            var reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload=function(e){
            attrs.$set('src',e.target.result);
            }
          },1)

          }
          else
          {
            scope.view="document";
            scope.$apply(scope.view)
          }
        },10);
        }
          }
      }
      }]).directive('removeFile', ['$parse','$timeout', function ($parse,$timeout) {
return {
  restrict: 'A',
  scope:{
    remove:"=",
    data:"="
  },
    link: function(scope,ele,attrs){
        var index=scope.remove;
        var data=scope.data;
        ele.bind('click', function(){
            data.splice(index,1);

        })


    }
  }

}]).directive('removeAll', ['$parse','$timeout', function ($parse,$timeout) {
return {
  restrict: 'A',
  scope:{
    removeAll:"="
  },
    link: function(scope,ele,attrs){
           ele.bind('click', function()
        {
            scope.removeAll=[]
            scope.$apply(scope.removeAll);
        })


    }
  }

}]);
